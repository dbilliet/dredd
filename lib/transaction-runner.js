// Generated by CoffeeScript 1.9.1
var Pitboss, TransactionRunner, addHooks, async, chai, flattenHeaders, gavel, http, https, logger, os, packageConfig, path, sortTransactions, url,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

http = require('http');

https = require('https');

url = require('url');

path = require('path');

os = require('os');

chai = require('chai');

gavel = require('gavel');

async = require('async');

Pitboss = require('pitboss').Pitboss;

flattenHeaders = require('./flatten-headers');

addHooks = require('./add-hooks');

sortTransactions = require('./sort-transactions');

packageConfig = require('./../package.json');

logger = require('./logger');

TransactionRunner = (function() {
  function TransactionRunner(configuration1) {
    this.configuration = configuration1;
    this.executeTransaction = bind(this.executeTransaction, this);
    this.executeAllTransactions = bind(this.executeAllTransactions, this);
    this.configureTransaction = bind(this.configureTransaction, this);
    this.hookStash = {};
  }

  TransactionRunner.prototype.config = function(config) {
    this.configuration = config;
    return this.multiBlueprint = Object.keys(this.configuration.data).length > 1;
  };

  TransactionRunner.prototype.run = function(transactions, callback) {
    transactions = this.configuration.options['sorted'] ? sortTransactions(transactions) : transactions;
    async.mapSeries(transactions, this.configureTransaction, function(err, results) {
      return transactions = results;
    });
    return addHooks(this, transactions, (function(_this) {
      return function(addHooksError) {
        if (addHooksError) {
          callback(addHooksError);
        }
        return _this.executeAllTransactions(transactions, _this.hooks, callback);
      };
    })(this));
  };

  TransactionRunner.prototype.runHooksForData = function(hooks, data, legacy, callback) {
    var runHookWithData;
    if (legacy == null) {
      legacy = false;
    }
    if ((hooks != null) && Array.isArray(hooks)) {
      logger.debug('Running hooks...');
      runHookWithData = (function(_this) {
        return function(hookFnIndex, callback) {
          var error, hookFn, ref;
          hookFn = hooks[hookFnIndex];
          try {
            if (legacy) {
              return _this.runLegacyHook(hookFn, data, function(err) {
                var error;
                if (err) {
                  error = new Error(err);
                  _this.emitError(data, error);
                }
                return callback();
              });
            } else {
              return _this.runHook(hookFn, data, function(err) {
                var error;
                if (err) {
                  error = new Error(err);
                  _this.emitError(data, error);
                }
                return callback();
              });
            }
          } catch (_error) {
            error = _error;
            if (error instanceof chai.AssertionError) {
              data.message = "Failed assertion in hooks: " + error.message;
              if ((ref = data.test) != null) {
                ref.status = 'fail';
              }
              _this.configuration.emitter.emit('test fail', data.test);
            } else {
              _this.emitError(data, error);
            }
            return callback();
          }
        };
      })(this);
      return async.timesSeries(hooks.length, runHookWithData, function() {
        return callback();
      });
    } else {
      return callback();
    }
  };

  TransactionRunner.prototype.emitError = function(transaction, error) {
    var test;
    test = {
      status: '',
      title: transaction.id,
      message: transaction.name,
      origin: transaction.origin
    };
    if (error) {
      return this.configuration.emitter.emit('test error', error, test);
    }
  };

  TransactionRunner.prototype.runLegacyHook = function(hook, data, callback) {
    var pitboss, wrappedCode;
    if (typeof hook === 'function') {
      if (hook.length === 1) {
        logger.warn("DEPRECATION WARNING!");
        logger.warn("You are using only one argument for the `beforeAll` or `afterAll` hook function.");
        logger.warn("One argument hook functions will be treated as synchronous in next major release.");
        logger.warn("To keep the async behaviour, just define hook function with two parameters. ");
        logger.warn("");
        logger.warn("Api of the hooks functions will be unified soon across all hook functions:");
        logger.warn(" - `beforeAll` and `afterAll` hooks will support sync API depending on number of arguments");
        logger.warn(" - API of callback all functions will be the same");
        logger.warn(" - First passed argument will be a `transactions` object");
        logger.warn(" - Second passed argument will be a optional callback function for async");
        logger.warn(" - `transactions` object in `hooks` module object will be removed");
        logger.warn(" - Manipulation of transactions will have to be performed on first function argument");
        hook(callback);
      } else if (hook.length === 2) {
        hook(data, function() {
          return callback();
        });
      }
    }
    if (typeof hook === 'string') {
      wrappedCode = "// run the hook\nvar _func = " + hook + ";\n_func(_data);\n\n// setup the return object\nvar output = {};\noutput[\"data\"] = _data;\noutput[\"stash\"] = stash;\noutput;";
      pitboss = new Pitboss(wrappedCode, {
        timeout: 500
      });
      return pitboss.run({
        context: {
          "_data": data,
          stash: this.hookStash
        },
        libraries: ['console']
      }, (function(_this) {
        return function(err, result) {
          var key, ref, ref1, ref2, ref3, value;
          if (result == null) {
            result = {};
          }
          if ((ref = pitboss.runner) != null) {
            if ((ref1 = ref.proc) != null) {
              ref1.removeAllListeners('exit');
            }
          }
          if ((ref2 = pitboss.runner) != null) {
            if (typeof ref2.kill === "function") {
              ref2.kill();
            }
          }
          if (err) {
            return callback(err);
          }
          ref3 = result.data || {};
          for (key in ref3) {
            value = ref3[key];
            data[key] = value;
          }
          _this.hookStash = result.stash;
          return callback();
        };
      })(this));
    }
  };

  TransactionRunner.prototype.runHook = function(hook, data, callback) {
    var pitboss, wrappedCode;
    if (typeof hook === 'function') {
      if (hook.length === 1) {
        hook(data);
        callback();
      } else if (hook.length === 2) {
        hook(data, function() {
          return callback();
        });
      }
    }
    if (typeof hook === 'string') {
      wrappedCode = "// run the hook\nvar _func = " + hook + ";\n_func(_data);\n\n// setup the return object\nvar output = {};\noutput[\"data\"] = _data;\noutput[\"stash\"] = stash;\noutput;";
      pitboss = new Pitboss(wrappedCode, {
        timeout: 500
      });
      return pitboss.run({
        context: {
          "_data": data,
          stash: this.hookStash
        },
        libraries: ['console']
      }, (function(_this) {
        return function(err, result) {
          var key, ref, ref1, ref2, ref3, value;
          if (result == null) {
            result = {};
          }
          if ((ref = pitboss.runner) != null) {
            if ((ref1 = ref.proc) != null) {
              ref1.removeAllListeners('exit');
            }
          }
          if ((ref2 = pitboss.runner) != null) {
            if (typeof ref2.kill === "function") {
              ref2.kill();
            }
          }
          if (err) {
            return callback(err);
          }
          ref3 = result.data || {};
          for (key in ref3) {
            value = ref3[key];
            data[key] = value;
          }
          _this.hookStash = result.stash;
          return callback();
        };
      })(this));
    }
  };

  TransactionRunner.prototype.configureTransaction = function(transaction, callback) {
    var configuration, configuredTransaction, expected, flatHeaders, fullPath, header, headerKey, headerValue, i, id, len, name, origin, parsedUrl, ref, request, response, splitIndex, system;
    configuration = this.configuration;
    origin = transaction['origin'];
    request = transaction['request'];
    response = transaction['response'];
    parsedUrl = url.parse(configuration['server']);
    if (parsedUrl['path'] === "/") {
      fullPath = request['uri'];
    } else {
      fullPath = '/' + [parsedUrl['path'].replace(/^\/|\/$/g, ""), request['uri'].replace(/^\/|\/$/g, "")].join("/");
    }
    flatHeaders = flattenHeaders(request['headers']);
    if (!flatHeaders['User-Agent']) {
      system = os.type() + ' ' + os.release() + '; ' + os.arch();
      flatHeaders['User-Agent'] = "Dredd/" + packageConfig['version'] + " (" + system + ")";
    }
    if (configuration.options.header.length > 0) {
      ref = configuration.options.header;
      for (i = 0, len = ref.length; i < len; i++) {
        header = ref[i];
        splitIndex = header.indexOf(':');
        headerKey = header.substring(0, splitIndex);
        headerValue = header.substring(splitIndex + 1);
        flatHeaders[headerKey] = headerValue;
      }
    }
    request['headers'] = flatHeaders;
    name = this.getTransactionName(transaction);
    id = request['method'] + ' ' + request['uri'];
    expected = {
      headers: flattenHeaders(response['headers']),
      body: response['body'],
      statusCode: response['status']
    };
    if (response['schema']) {
      expected['bodySchema'] = response['schema'];
    }
    configuredTransaction = {
      name: name,
      id: id,
      host: parsedUrl['hostname'],
      port: parsedUrl['port'],
      request: request,
      expected: expected,
      origin: origin,
      fullPath: fullPath,
      protocol: parsedUrl.protocol,
      skip: false
    };
    return callback(null, configuredTransaction);
  };

  TransactionRunner.prototype.emitResult = function(transaction, callback) {
    if (transaction.test) {
      if (transaction.test.valid === true) {
        if (transaction.fail) {
          transaction.test.status = 'fail';
          transaction.test.message = "Failed in after hook: " + transaction.fail;
          this.configuration.emitter.emit('test fail', transaction.test);
        } else {
          this.configuration.emitter.emit('test pass', transaction.test);
        }
      }
    }
    return callback();
  };

  TransactionRunner.prototype.executeAllTransactions = function(transactions, hooks, callback) {
    var i, len, transaction;
    if (hooks.transactions == null) {
      hooks.transactions = {};
      for (i = 0, len = transactions.length; i < len; i++) {
        transaction = transactions[i];
        hooks.transactions[transaction.name] = transaction;
      }
    }
    return this.runHooksForData(hooks.beforeAllHooks, transactions, true, (function(_this) {
      return function() {
        return async.timesSeries(transactions.length, function(transactionIndex, iterationCallback) {
          transaction = transactions[transactionIndex];
          return _this.runHooksForData(hooks.beforeEachHooks, transaction, false, function() {
            return _this.runHooksForData(hooks.beforeHooks[transaction.name], transaction, false, function() {
              return _this.executeTransaction(transaction, function() {
                return _this.runHooksForData(hooks.afterEachHooks, transaction, false, function() {
                  return _this.runHooksForData(hooks.afterHooks[transaction.name], transaction, false, function() {
                    return _this.emitResult(transaction, iterationCallback);
                  });
                });
              });
            });
          });
        }, function() {
          return _this.runHooksForData(hooks.afterAllHooks, transactions, true, callback);
        });
      };
    })(this));
  };

  TransactionRunner.prototype.executeTransaction = function(transaction, callback) {
    var buffer, caseInsensitiveRequestHeadersMap, configuration, error, handleRequest, key, ref, ref1, ref2, req, requestOptions, test, transport, value;
    configuration = this.configuration;
    caseInsensitiveRequestHeadersMap = {};
    ref = transaction.request.headers;
    for (key in ref) {
      value = ref[key];
      caseInsensitiveRequestHeadersMap[key.toLowerCase()] = key;
    }
    if (!caseInsensitiveRequestHeadersMap['content-length'] && transaction.request['body'] !== '') {
      transaction.request.headers['Content-Length'] = Buffer.byteLength(transaction.request['body'], 'utf8');
    }
    requestOptions = {
      host: transaction.host,
      port: transaction.port,
      path: transaction.fullPath,
      method: transaction.request['method'],
      headers: transaction.request.headers
    };
    test = {
      status: '',
      title: transaction.id,
      message: transaction.name,
      origin: transaction.origin
    };
    configuration.emitter.emit('test start', test);
    if (transaction.skip) {
      configuration.emitter.emit('test skip', test);
      return callback();
    } else if (transaction.fail) {
      test.message = "Failed in before hook: " + transaction.fail;
      configuration.emitter.emit('test fail', test);
      return callback();
    } else if (configuration.options['dry-run']) {
      logger.info("Dry run, skipping API Tests...");
      transaction.skip = true;
      return callback();
    } else if (configuration.options.names) {
      logger.info(transaction.name);
      transaction.skip = true;
      return callback();
    } else if (configuration.options.method.length > 0 && !(ref1 = transaction.request.method, indexOf.call(configuration.options.method, ref1) >= 0)) {
      configuration.emitter.emit('test skip', test);
      transaction.skip = true;
      return callback();
    } else if (configuration.options.only.length > 0 && !(ref2 = transaction.name, indexOf.call(configuration.options.only, ref2) >= 0)) {
      configuration.emitter.emit('test skip', test);
      transaction.skip = true;
      return callback();
    } else {
      buffer = "";
      handleRequest = function(res) {
        res.on('data', function(chunk) {
          return buffer = buffer + chunk;
        });
        req.on('error', function(error) {
          if (error) {
            return configuration.emitter.emit('test error', error, test);
          }
        });
        return res.on('end', function() {
          var real;
          real = {
            statusCode: res.statusCode,
            headers: res.headers,
            body: buffer
          };
          transaction['real'] = real;
          return gavel.isValid(real, transaction.expected, 'response', function(isValidError, isValid) {
            if (isValidError) {
              configuration.emitter.emit('test error', isValidError, test);
            }
            test.start = test.start;
            test.title = transaction.id;
            test.actual = real;
            test.expected = transaction.expected;
            test.request = transaction.request;
            if (isValid) {
              test.status = "pass";
            } else {
              test.status = "fail";
            }
            return gavel.validate(real, transaction.expected, 'response', function(validateError, result) {
              var data, entityResult, i, len, message, ref3, resultKey;
              if (!isValidError && validateError) {
                configuration.emitter.emit('test error', validateError, test);
              }
              message = '';
              for (resultKey in result) {
                data = result[resultKey];
                if (resultKey !== 'version') {
                  ref3 = data['results'];
                  for (i = 0, len = ref3.length; i < len; i++) {
                    entityResult = ref3[i];
                    message += resultKey + ": " + entityResult['message'] + "\n";
                  }
                }
              }
              test.message = message;
              test.results = result;
              test.valid = isValid;
              transaction.test = test;
              if (test.valid === false) {
                configuration.emitter.emit('test fail', test);
              }
              return callback();
            });
          });
        });
      };
      transport = transaction.protocol === 'https:' ? https : http;
      if (transaction.request['body'] && this.isMultipart(requestOptions)) {
        this.replaceLineFeedInBody(transaction, requestOptions);
      }
      try {
        req = transport.request(requestOptions, handleRequest);
        if (transaction.request['body'] !== '') {
          req.write(transaction.request['body']);
        }
        return req.end();
      } catch (_error) {
        error = _error;
        if (error) {
          configuration.emitter.emit('test error', error, test);
        }
        return callback();
      }
    }
  };

  TransactionRunner.prototype.isMultipart = function(requestOptions) {
    var caseInsensitiveRequestHeaders, key, ref, ref1, value;
    caseInsensitiveRequestHeaders = {};
    ref = requestOptions.headers;
    for (key in ref) {
      value = ref[key];
      caseInsensitiveRequestHeaders[key.toLowerCase()] = value;
    }
    return ((ref1 = caseInsensitiveRequestHeaders['content-type']) != null ? ref1.indexOf("multipart") : void 0) > -1;
  };

  TransactionRunner.prototype.replaceLineFeedInBody = function(transaction, requestOptions) {
    if (transaction.request['body'].indexOf('\r\n') === -1) {
      transaction.request['body'] = transaction.request['body'].replace(/\n/g, '\r\n');
      transaction.request['headers']['Content-Length'] = Buffer.byteLength(transaction.request['body'], 'utf8');
      return requestOptions.headers = transaction.request['headers'];
    }
  };

  TransactionRunner.prototype.getTransactionName = function(transaction) {
    var name, origin;
    origin = transaction['origin'];
    name = '';
    if (this.multiBlueprint) {
      name += origin['apiName'];
    }
    if (this.multiBlueprint) {
      name += ' > ';
    }
    if (origin['resourceGroupName'] !== "") {
      name += origin['resourceGroupName'];
    }
    if (origin['resourceGroupName'] !== "") {
      name += ' > ';
    }
    if (origin['resourceName']) {
      name += origin['resourceName'];
    }
    if (origin['actionName']) {
      name += ' > ' + origin['actionName'];
    }
    if (origin['exampleName']) {
      name += ' > ' + origin['exampleName'];
    }
    return name;
  };

  return TransactionRunner;

})();

module.exports = TransactionRunner;
