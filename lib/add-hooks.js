// Generated by CoffeeScript 1.9.1
var Hooks, addHooks, async, fs, glob, logger, mergeSandboxedHooks, path, proxyquire, sandboxHooksCode;

require('coffee-script/register');

path = require('path');

proxyquire = require('proxyquire').noCallThru();

glob = require('glob');

fs = require('fs');

async = require('async');

Hooks = require('./hooks');

logger = require('./logger');

sandboxHooksCode = require('./sandbox-hooks-code');

mergeSandboxedHooks = require('./merge-sandboxed-hooks');

addHooks = function(runner, transactions, callback) {
  var base, customConfigCwd, fixLegacyTransactionNames, i, len, msg, pattern, patternArray, ref, ref1, ref2, ref3, transaction;
  fixLegacyTransactionNames = function(allHooks) {
    var hookType, hooks, i, len, newTranscationName, pattern, ref, results, transactionName;
    pattern = /^\s>\s/g;
    ref = ['beforeHooks', 'afterHooks'];
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      hookType = ref[i];
      results.push((function() {
        var ref1, results1;
        ref1 = allHooks[hookType];
        results1 = [];
        for (transactionName in ref1) {
          hooks = ref1[transactionName];
          if (transactionName.match(pattern) !== null) {
            newTranscationName = transactionName.replace(pattern, '');
            if (allHooks[hookType][newTranscationName] !== void 0) {
              allHooks[hookType][newTranscationName] = hooks.concat(allHooks[hookType][newTranscationName]);
            } else {
              allHooks[hookType][newTranscationName] = hooks;
            }
            results1.push(delete allHooks[hookType][transactionName]);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      })());
    }
    return results;
  };
  runner.hooks = new Hooks();
  if ((base = runner.hooks).transactions == null) {
    base.transactions = {};
  }
  customConfigCwd = runner != null ? (ref = runner.configuration) != null ? (ref1 = ref.custom) != null ? ref1.cwd : void 0 : void 0 : void 0;
  for (i = 0, len = transactions.length; i < len; i++) {
    transaction = transactions[i];
    runner.hooks.transactions[transaction.name] = transaction;
  }
  pattern = runner != null ? (ref2 = runner.configuration) != null ? (ref3 = ref2.options) != null ? ref3.hookfiles : void 0 : void 0 : void 0;
  if (!pattern) {
    if (runner.configuration.hooksData != null) {
      if (runner.configuration.options.sandbox === true) {
        if (typeof runner.configuration.hooksData !== 'object' || Array.isArray(runner.configuration.hooksData) !== false) {
          return callback(new Error("hooksData option must be an object e.g. {'filename.js':'console.log(\"Hey!\")'}"));
        }
        return async.eachSeries(Object.keys(runner.configuration.hooksData), function(key, nextHook) {
          var data;
          data = runner.configuration.hooksData[key];
          return sandboxHooksCode(data, function(sandboxError, result) {
            if (sandboxError) {
              return nextHook(sandboxError);
            }
            runner.hooks = mergeSandboxedHooks(runner.hooks, result);
            fixLegacyTransactionNames(runner.hooks);
            return nextHook();
          });
        }, callback);
      } else {
        msg = "Not sandboxed hooks loading from strings is not implemented,\nSandbox mode must be enabled when loading hooks from strings.\"";
        return callback(new Error(msg));
      }
    } else {
      return callback();
    }
  } else {
    patternArray = [].concat(pattern);
    return async.eachSeries(patternArray, function(item, nextPattern) {
      var error, file, files, j, len1;
      files = glob.sync(item);
      logger.info('Found Hookfiles: ' + files);
      if (!runner.configuration.options.sandbox === true) {
        try {
          for (j = 0, len1 = files.length; j < len1; j++) {
            file = files[j];
            proxyquire(path.resolve(customConfigCwd || process.cwd(), file), {
              'hooks': runner.hooks
            });
          }
          fixLegacyTransactionNames(runner.hooks);
          return nextPattern();
        } catch (_error) {
          error = _error;
          logger.warn('Skipping hook loading...');
          logger.warn('Error reading hook files (' + files + ')');
          logger.warn('This probably means one or more of your hookfiles is invalid.');
          if (error.message != null) {
            logger.warn('Message: ' + error.message);
          }
          if (error.stack != null) {
            logger.warn('Stack: ' + error.stack);
          }
          return nextPattern();
        }
      } else {
        logger.info('Loading hookfiles in sandboxed context' + files);
        return async.eachSeries(files, function(fileName, nextFile) {
          var resolvedPath;
          resolvedPath = path.resolve(customConfigCwd || process.cwd(), fileName);
          return fs.readFile(resolvedPath, 'utf8', function(readingError, data) {
            if (readingError) {
              return nextFile(readingError);
            }
            return sandboxHooksCode(data, function(sandboxError, result) {
              if (sandboxError) {
                return nextFile(sandboxError);
              }
              runner.hooks = mergeSandboxedHooks(runner.hooks, result);
              fixLegacyTransactionNames(runner.hooks);
              return nextFile();
            });
          });
        }, nextPattern);
      }
    }, callback);
  }
};

module.exports = addHooks;
